Single-Survey Analysis
========================================================

```{r load packages and RData}
rm(list=ls())

library(data.table)
library(reshape)
library(dplyr)
library(rjags)
library(parallel)
library(detect)
library(ggplot2)
```

## Read in data
```{r read in data, results='hide'}
load("data/Shen Dail Madsen data and results ver 6.8.RData") 

load("data/annual-site-climate.RData")

sites <- fread("inst/extdata/72-sites-order.csv")
```

```{r results = 'hide'}
yoy.1 <- data.frame(Dat$y[1:72, 2:15, 1, 1]) # all sites, all years, yoy, pass 1
adult.1 <- data.frame(Dat$y[1:72, 2:15, 2, 1]) # all sites, all years, adult, pass 1
Jdate <- data.frame(Dat$Jdate[1:72, 2:15])
width <- data.frame(Dat$width[1:72, 2:15])

yoy.1$site <- row.names(yoy.1)
colnames(yoy.1) <- c(1997:2010, "site")
yoy <- melt(yoy.1, id = "site")
colnames(yoy) <- c("site", "year", "c.yoy")

adult.1$site <- row.names(adult.1)
colnames(adult.1) <- c(1997:2010, "site")
adult <- melt(adult.1, id = "site")
colnames(adult) <- c("site", "year", "c.adults")

Jdate$site <- row.names(Jdate)
colnames(Jdate) <- c(1997:2010, "site")
date <- melt(Jdate, id = "site")
colnames(date) <- c("site", "year", "day")

width$site <- row.names(width)
colnames(width) <- c(1997:2010, "site")
width <- melt(width, id = "site")
colnames(width) <- c("site", "year", "width")


pass1 <- data.frame(adult, yoy[ , "c.yoy"], date[ , "day"], width[ , "width"])
colnames(pass1) <- c("site", "year", "c.adults", "c.yoy", "day", "width")

pass1$elev <- Dat$elev

# flow and temp assumed to be equal across all sites but varied by year
pass1$fall.flow <- rep(Dat$fall.flow, times = 1, each=72)
pass1$winter.flow <- rep(Dat$winter.flow , times = 1, each=72)
pass1$spring.flow <- rep(Dat$spring.flow, times = 1, each=72)
pass1$spring.temp <- rep(Dat$spring.temp, times = 1, each=72)

# Unify Yoichiro and Park Service Site Names for joining other landscape data
for(i in 1:length(sites$SiteID)) {
  sites$site[i] <- paste0("Site", i)
  }
# temp vary by site and year
annual.site.climate$fyear <- as.factor(annual.site.climate$year)
pass1$fyear <- as.factor(pass1$year)
annual.site.climate$SiteID2 <- annual.site.climate$site
annual.site.climate <- subset(annual.site.climate, select = -c(site))
annual.site.climate <- left_join(annual.site.climate, sites, by = c("SiteID2"))

# Convert to climate to wide format so have different variables for seasonal temp
annual.site.climate <- subset(annual.site.climate,  select = c("year", "season", "mean.tmean", "mean.precip", "fyear", "SiteID", "SiteID2", "site"))
#annual.site.climate$site.year <- paste0(annual.site.climate$site, "-", annual.site.climate$year)
climate.wide <- reshape(annual.site.climate, idvar = c("site", "year", "fyear", "SiteID", "SiteID2"), timevar = "season", direction = "wide") # varying = list("mean.tmean", "mean.precip")

pass1$c.year <- as.character(pass1$year)
climate.wide$c.year <- as.character(climate.wide$year)

pass1 <- left_join(pass1, climate.wide, by = c("site", "c.year"))

pass1$mean.tmean.Spring1 <- pass1$mean.tmean.Spring
pass1$mean.tmean.Spring <- (pass1$mean.tmean.Spring - mean(pass1$mean.tmean.Spring)) / sd(pass1$mean.tmean.Spring)


head(pass1)
str(pass1)
summary(pass1)

pass1$site <- as.factor(pass1$site)
pass1$fyear <- pass1$year.x
pass1$year <- as.integer(pass1$year.x)

str(pass1)
```

### GLM

```{r glm}

adult.glm.1 <- glm(c.adults ~ fall.flow + winter.flow + spring.flow + mean.tmean.Spring + elev + year + day + width, data = pass1, family = "poisson")

summary(adult.glm.1)
```

```{r glmm Adult}

library(lme4)

adult.glmm.p <- glmer(c.adults ~ fall.flow + winter.flow + spring.flow + mean.tmean.Spring + elev + day + width + (1|site), data = pass1, family = "poisson", control=glmerControl(optimizer="bobyqa"))

summary(adult.glmm.p)

data.full <- dplyr::select(pass1, site, fyear, fall.flow, winter.flow, spring.flow, mean.tmean.Spring, elev, day, width)
predictions <- predict(adult.glmm.p, newdata = data.full)

library(arm) # for posterior predictive confidence intervals (only works for fitted values)
adult.glmm.p.sim <- sim(adult.glmm.p, n.sims = 1000)
str(adult.glmm.p.sim)
yhat <- fitted(adult.glmm.p.sim, adult.glmm.p)

Nhat.glmm.p <- apply(yhat, MARGIN = 1, FUN = mean)
uci.glmm.p <- apply(yhat, MARGIN = 1, FUN = quantile, probs = c(0.975))
lci.glmm.p <- apply(yhat, MARGIN = 1, FUN = quantile, probs = c(0.025))

N.glmm <- data.frame(N = Nhat.glmm.p, lci = lci.glmm.p, uci = uci.glmm.p)

# Predictions with CI using bootMer
myPredict <- function(.) {
  preds <- exp(predict(., newdata = data.full))
  return(preds)
}
test <- myPredict(adult.glmm.p)
yhat.boot <- bootMer(adult.glmm.p, FUN = myPredict, nsim = 100)

Nhat.glmm.p <- apply(yhat.boot$t, MARGIN = 2, FUN = mean, na.rm = TRUE)
uci.glmm.p <- apply(yhat.boot$t, MARGIN = 2, FUN = quantile, probs = c(0.975), na.rm = TRUE)
lci.glmm.p <- apply(yhat.boot$t, MARGIN = 2, FUN = quantile, probs = c(0.025), na.rm = TRUE)

N.glmm.adult <- data.frame(N = Nhat.glmm.p, lci = lci.glmm.p, uci = uci.glmm.p)
```

```{r test optimization for glmer}
g0.default <- glmer(c.adults ~ fall.flow + winter.flow + spring.flow + spring.temp + elev + day + width + (1|site), data = pass1, family = "poisson")
g0.bobyqa <- glmer(c.adults ~ fall.flow + winter.flow + spring.flow + spring.temp + elev + day + width + (1|site), data = pass1, family = "poisson", control=glmerControl(optimizer="bobyqa"))

g0.NM <- update(g0.bobyqa,control=glmerControl(optimizer="Nelder_Mead"))
library(optimx)
g0.nlminb <- update(g0.bobyqa,control=glmerControl(optimizer="optimx",
                              optCtrl=list(method="nlminb")))
g0.LBFGSB <- update(g0.bobyqa,control=glmerControl(optimizer="optimx",
                              optCtrl=list(method="L-BFGS-B")))

library(nloptr)
## from https://github.com/lme4/lme4/issues/98:
defaultControl <- list(algorithm="NLOPT_LN_BOBYQA",xtol_rel=1e-6,maxeval=1e5)
nloptwrap2 <- function(fn,par,lower,upper,control=list(),...) {
    for (n in names(defaultControl)) 
      if (is.null(control[[n]])) control[[n]] <- defaultControl[[n]]
    res <- nloptr(x0=par,eval_f=fn,lb=lower,ub=upper,opts=control,...)
    with(res,list(par=solution,
                  fval=objective,
                  feval=iterations,
                  conv=if (status>0) 0 else status,
                  message=message))
}
g0.bobyqa2 <- update(g0.bobyqa,control=glmerControl(optimizer=nloptwrap2))
g0.NM2 <- update(g0.bobyqa,control=glmerControl(optimizer=nloptwrap2,
                           optCtrl=list(algorithm="NLOPT_LN_NELDERMEAD")))

getpar <- function(x) c(getME(x,c("theta")),fixef(x))
modList <- list(bobyqa=g0.bobyqa,NM=g0.NM,nlminb=g0.nlminb,
                bobyqa2=g0.bobyqa2,NM2=g0.NM2,LBFGSB=g0.LBFGSB, g0.default=g0.default)
ctab <- sapply(modList,getpar)
library(reshape2)
mtab <- melt(ctab)
library(ggplot2)
theme_set(theme_bw())
ggplot(mtab,aes(x=X2,y=value,colour=X2))+
    geom_point()+facet_wrap(~X1,scale="free")

summary(cvvec <- apply(ctab,1,function(x) sd(x)/mean(x)))

likList <- sapply(modList,logLik)
round(log10(max(likList)-likList),1)
```

```{r glmm YOY}
yoy.glmm.p <- glmer(c.yoy ~ fall.flow + winter.flow + spring.flow + mean.tmean.Spring + elev + day + width + (1|site), data = pass1, family = "poisson", control=glmerControl(optimizer="bobyqa"))

summary(yoy.glmm.p)

yhat.boot <- bootMer(yoy.glmm.p, FUN = myPredict, nsim = 100)

Nhat.glmm.p <- apply(yhat.boot$t, MARGIN = 2, FUN = mean, na.rm = TRUE)
uci.glmm.p <- apply(yhat.boot$t, MARGIN = 2, FUN = quantile, probs = c(0.975), na.rm = TRUE)
lci.glmm.p <- apply(yhat.boot$t, MARGIN = 2, FUN = quantile, probs = c(0.025), na.rm = TRUE)

N.glmm.yoy <- data.frame(N = Nhat.glmm.p, lci = lci.glmm.p, uci = uci.glmm.p)
```

Quick models of abundance using the `detect` package. Modelled all site-visits as independent so technically pseudoreplicated. The problem is there is no way to have random effects of site or year. Unfortunately, there is insufficient data from Yoichiro's Dail-Madsen model to independently model each year separately in `detect`. Also, the flows and temperatures are assumed to be equal across all sites in a given year, so I can't have year as a factor in the model while retaining flow or temperature because they are colinear.

```{r detect}
adult.detect.1 <- svabu(c.adults ~ fall.flow + winter.flow + spring.flow + mean.tmean.Spring + elev | day + width, data = pass1, zeroinfl = TRUE)
summary(adult.detect.1)

adult.detect.2 <- svabu(c.adults ~ fall.flow + winter.flow + spring.flow + mean.tmean.Spring + elev + fyear | day + width, data = pass1) # doesn't work
summary(adult.detect.2)

adult.detect.3 <- svabu(c.adults ~ fall.flow + winter.flow + spring.flow + mean.tmean.Spring + elev | day + width, data = pass1, zeroinfl = FALSE)
summary(adult.detect.3)

adult.detect.4 <- svabu(c.adults ~ elev + fyear | day + width, data = pass1, zeroinfl = TRUE)
summary(adult.detect.4)

AIC(adult.detect.1, adult.detect.3, adult.detect.4) # better to just have year effects than specific covariates. There are other things going on besides mean seaonal flow and temp that affect abundance that vary across the whole park annually. Ideally there would be random year and site effects with covariates. Also problem that flow and temperature are identical across all sites.
 
yoy.detect.1 <- svabu(c.yoy ~ fall.flow + winter.flow + spring.flow + mean.tmean.Spring + elev | day + width, data = pass1, zeroinfl = TRUE)
summary(yoy.detect.1)
exp(predict(yoy.detect.1))
mean(exp(predict(yoy.detect.1)))

```


```{r confidence intervals}
 
  CL <- makeCluster(10) # set number of clusters
  clusterExport(cl=CL, list("adult.detect.1", "pass1", "data.full", "bootSingleVisit", "groupResample"), envir = environment()) # make data available to jags in diff cores
  clusterSetRNGStream(cl = CL)
  
  out <- clusterEvalQ(CL, {
    library(detect)
    preds <- bootSingleVisit(adult.detect.1, pass1, data.full, nsim = 1)
    return(preds)
    
  })
  stopCluster(CL)

N.adult <- matrix(unlist(out), nrow = nrow(data.full))

N.adult.1 <- N.adult
N.adult.2 <- N.adult
N.adult.3 <- N.adult
N.adult.4 <- N.adult
N.adult.5 <- N.adult
N.adult.6 <- N.adult
N.adult.7 <- N.adult
N.adult.8 <- N.adult
N.adult.9 <- N.adult
N.adult.10 <- N.adult

N.adult.boot <- data.frame(N.adult.1,
                              N.adult.2,
                              N.adult.3,
                              N.adult.4,
                              N.adult.5,
                              N.adult.6,
                              N.adult.7,
                              N.adult.8,
                              N.adult.9,
                              N.adult.10)

N.adult.boot <- data.frame(N.adult, N.combine)

save(N.adult.boot, file = 'data/N-detect-adult.RData')
save(N.adult.combine, file = 'C:/Users/dhocking/Dropbox/')


  CL <- makeCluster(4) # set number of clusters
  clusterExport(cl=CL, list("yoy.detect.1", "pass1", "data.full", "nsim", "bootSingleVisit", "groupResample"), envir = environment()) # make data available to jags in diff cores
  clusterSetRNGStream(cl = CL, iseed = 10101)
  
  out <- clusterEvalQ(CL, {
    library(detect)
    preds <- bootSingleVisit(yoy.detect.1, pass1, data.full, nsim = 25)
    return(preds)
    
  })
  stopCluster(CL)

matrix(unlist(out), nrow = nrow(data.full))

```


```{r summaries}
library(dplyr)
adult.n <- as.data.frame(exp(predict(adult.detect.1))) # missing predictions due to NA in data?
colnames(adult.n) <- c("N")
adult.n$trip <- paste("trip", row.names(adult.n), sep = "")
pass1$trip <- paste("trip", row.names(pass1), sep = "")

adult.n <- left_join(x = pass1, y = adult.n, by = "trip")
str(adult.n)

# adult.n <- as.data.frame(exp(predict(adult.detect.1)), pass1)
adult.n$year <- adult.n$year + 1996

g <- group_by(adult.n, year)
summarise(g, mean = mean(N, na.rm = TRUE)) # not sure why this isn't grouping by year

agg.adult <- aggregate(adult.n, by = list(adult.n$year), FUN = mean, na.rm = TRUE)

agg.adult$N.pop <- agg.adult$N * 72


yoy.n <- as.data.frame(exp(predict(yoy.detect.1))) # missing predictions due to NA in data
colnames(yoy.n) <- c("N")
yoy.n$trip <- paste("trip", row.names(yoy.n), sep = "")
pass1$trip <- paste("trip", row.names(pass1), sep = "")

yoy.n <- left_join(x = pass1, y = yoy.n, by = "trip")
str(yoy.n)

# yoy.n <- as.data.frame(exp(predict(yoy.detect.1)), pass1)
yoy.n$year <- yoy.n$year + 1996

g <- group_by(yoy.n, year)
summarise(g, mean = mean(N, na.rm = TRUE)) # not sure why this isn't grouping by year

agg.yoy <- aggregate(yoy.n, by = list(yoy.n$year), FUN = mean, na.rm = TRUE)

agg.yoy$N.pop <- agg.yoy$N * 72
```


